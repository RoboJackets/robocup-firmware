<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GT RoboCup SSL: FPGA</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="rj_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GT RoboCup SSL
   </div>
   <div id="projectbrief">Soccer software, robot firmware</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc__f_p_g_a.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">FPGA </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document was originally written Fall of 2019 after the mtrain implementation. The latest relevant branch was comp2019. Knowing robocup, this won't be updated to the latest version of firmware, but hopefully it will still describe most everything. - Joe Neiger</p>
<h1>FPGA</h1>
<p>This document will lightly touch the FPGA verilog code, motor physics, and the communication protocol. I (Joe) have not personally worked on the FPGA code so this is all from my reading and debugging of the code over the years.</p>
<h2>FPGA Code</h2>
<p>On the high level, the FPGA takes in motor speed commands over SPI, communicates specific phases high and low to the motor driver, reads the encoder values, and returns the encoder values and delta time over SPI.</p>
<p>One big thing to keep in mind as you work with the FPGA, from the mtrain side, there is a built in watchdog in the FPGA. You must command motor values consistently or toggle the motors on-&gt;off-&gt;on otherwise the watchdog will trigger.</p>
<h2>Motor Lowdown</h2>
<p>RoboCup uses BLDC motors for all their movement needs. BLDC (Brushless DC) basically means that instead of using brushes to swap the positive and negative magnetic poles in the motor, we do it electrically. There are 3 phases evenly distributed around the physical device. You can rotate a magnet through a full circle by turning on the attraction side in front of the magnet, turning on the repellent side behind the magnet, and letting the third one just sit without a field. This will allow for rotations of the magnet itself. These three phases are called A, B, and C. To actually cause the motor to rotate, you need to know where the magnet is located in it's rotation. We use hall effect sensors for this purpose. They are very course grain position sensors who's output is which 60 degree quadrant you are in. This is perfect for interfacing with the 3 phases. A simple state machine can be built that says for each quadrant, a specific combination of phases should be turned on and off. To get the speed correct, you can change the voltage going to the motors. This is done using PWM (Pulse Width Modulation). One can easily imagine this by turning off and on the power very quickly to the motor.</p>
<h2>Communication Protocol</h2>
<p>The mtrain &lt;-&gt; fpga communciation through SPI is built up using a command based system. The first byte sent represents the type of data.</p>
<table class="doxtable">
<tr>
<th>Command </th><th>Hex </th><th>Description  </th></tr>
<tr>
<td>Disable Motors </td><td>0x30 </td><td>Disables all motors </td></tr>
<tr>
<td>Enable Motors </td><td>0xB0 </td><td>Enables all motors </td></tr>
<tr>
<td>Read Encoders Write Vel </td><td>0x80 </td><td>Writes each of the 5 duty cycles out to the FPGA while reading encoders and dt at the same time </td></tr>
<tr>
<td>Read Encoders </td><td>0x91 </td><td>Reads back all 4 encoders and the dt </td></tr>
<tr>
<td>Read Halls </td><td>0x92 </td><td>Reads back all 5 hall effect sensors </td></tr>
<tr>
<td>Read Duty </td><td>0x93 </td><td>Reads back all 5 currently commanded duty cycles </td></tr>
<tr>
<td>Read Hash Pt 1</td><td>0x94 </td><td>Reads the second half of the git hash of the fpga </td></tr>
<tr>
<td>Read Hash Pt 2</td><td>0x95 </td><td>Reads the first half of the git hash of the fpga </td></tr>
<tr>
<td>Check DRV </td><td>0x96 </td><td>Reads the config of the DRV3303 gate drivers </td></tr>
</table>
<h3>Disable/Enable Motor Format</h3>
<table class="doxtable">
<tr>
<th></th><th></th></tr>
<tr>
<td>Send </td><td>0x30/0xB0 </td></tr>
<tr>
<td>Receive</td><td>Status </td></tr>
</table>
<p>Enables or disables the motors based on the value.</p>
<p>Note: Toggle on-&gt;off-&gt;on resets the watchdog</p>
<h3>Read Encoders Write vel</h3>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x80 </td><td>Duty cycle #1 </td><td>Duty cycle #2 </td><td>Duty cycle #3 </td><td>Duty cycle #4 </td><td>Duty cycle #5 </td></tr>
<tr>
<td>Receive </td><td>Status</td><td>Delta Enc #1 </td><td>Delta Enc #2 </td><td>Delta Enc #3 </td><td>Delta Enc #4 </td><td>Delta time </td></tr>
</table>
<p>Duty cycle is a 11 bit number in signed magnitude form (-511 to 511). The lower byte of the 16 bit number is sent, then the higher byte of the 16 bit number is sent. On the receiving side the high byte is sent first, then the lower byte. The Delta encoder values are signed 16 bit numbers.</p>
<p>Note: Writing this command resets the watchdog</p>
<h3>Read Encoders</h3>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x91 </td><td>0x0000 </td><td>0x0000 </td><td>0x0000 </td><td>0x0000 </td><td>0x0000 </td></tr>
<tr>
<td>Receive </td><td>Status </td><td>Delta Enc #1 </td><td>Delta Enc #2 </td><td>Delta Enc #3 </td><td>Delta Enc #4 </td><td>Delta time </td></tr>
</table>
<p>On the receiving side the high byte is sent first, then the lower byte. The Delta encoder values are signed 16 bit numbers.</p>
<h3>Read Halls</h3>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x92 </td><td>0x00 </td><td>0x00 </td><td>0x00 </td><td>0x00 </td><td>0x00 </td></tr>
<tr>
<td>Receive </td><td>Status </td><td>Hall #1 </td><td>Hall #2 </td><td>Hall #3 </td><td>Hall #4 </td><td>Hall #5 </td></tr>
</table>
<h3>Read Duty Cycle</h3>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x93 </td><td>0x0000 </td><td>0x0000 </td><td>0x0000 </td><td>0x0000 </td><td>0x0000 </td></tr>
<tr>
<td>Receive </td><td>Status </td><td>Duty Cycles #1 </td><td>Duty Cycles #2 </td><td>Duty Cycles #3 </td><td>Duty Cycles #4 </td><td>Duty Cycles #5 </td></tr>
</table>
<p>Duty cycle is a 11 bit number in signed magnitude form (-511 to 511). On the receiving side the high byte is sent first, then the lower byte.</p>
<h3>Git Hash 1/2</h3>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x94 </td><td>0x00 </td><td>0x00 </td><td>.... </td><td>0x00 </td><td>0x00 </td></tr>
<tr>
<td>Receive </td><td>Status </td><td>Char20 </td><td>Char19 </td><td>.... </td><td>Char12 </td><td>Char11 </td></tr>
</table>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x95 </td><td>0x00 </td><td>0x00 </td><td>.... </td><td>0x00 </td><td>0x00 </td></tr>
<tr>
<td>Receive </td><td>Status </td><td>Char10 </td><td>Char09 </td><td>.... </td><td>Char01 </td><td>Dirty </td></tr>
</table>
<p>If enabled returns the git hash of the fpga firmware. Care must be taken to flip the returned list of characters to get the correct git hash. Additionally, the last character back is <code>0x01</code> if the fpga firmware is dirty.</p>
<h3>Check DRV</h3>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Send </td><td>0x96 </td><td>0x00 </td><td>0x00 </td><td>0x00 </td><td>0x00 </td><td>.... </td></tr>
<tr>
<td>Receive </td><td>Status </td><td>Nib1 </td><td>Nib0 </td><td>0x00 </td><td>Nib2 </td><td>.... </td></tr>
</table>
<p>For 5 Nibble Set transactions (20 8 bit spi transactions).</p>
<p>Each nibble has a very specific output given by the table (MSB -&gt; LSB). See DRV data sheet for definitions.</p>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th><th></th></tr>
<tr>
<td>Nib2 </td><td>GVDD_OV </td><td>FAULT </td><td>GVDD_UV </td><td>PVDD_UV </td></tr>
<tr>
<td>Nib1 </td><td>OTSD </td><td>OTW </td><td>FETHA_OC </td><td>FETLA_OC </td></tr>
<tr>
<td>Nib0 </td><td>FETHB_OC </td><td>FETLB_OC </td><td>FETHC_OC </td><td>FETLC_OC </td></tr>
</table>
<h3>Return Status</h3>
<p>For every single packet, the first byte returned in the packet type class is the status. (MSB -&gt; LSB)</p>
<table class="doxtable">
<tr>
<th></th><th></th><th></th><th></th></tr>
<tr>
<td>System Ready </td><td>Watchdog Trigger </td><td>Motors Enabled </td><td>Motors Has Error[4..0] </td></tr>
</table>
<p>System ready is true when the system has finished the boot up configuration.</p>
<p>Watchdog Trigger is true when the watchdog times out</p>
<p>Motors Enabled is true when the commanded duty cycles will actually cause movement in the motors.</p>
<p>Motors Has Error is a 5 bit field that is true when that specific motor has a hall fault or the hall is not connected.</p>
<h2>DT Note</h2>
<p>The delta time at the end of most of the packets is very special and has an extremely crazy conversion. This snippet of code will do everything for you. Copy this wherever it is used to keep the documentation near it.</p>
<div class="fragment"><div class="line">/*</div><div class="line"> * The time since the last update is derived with the value of</div><div class="line"> * WATCHDOG_TIMER_CLK_WIDTH in robocup.v</div><div class="line"> *</div><div class="line"> * The last encoder reading (5th one) from the FPGA is the watchdog</div><div class="line"> * timer&#39;s tick since the last SPI transfer.</div><div class="line"> *</div><div class="line"> * Multiply the received tick count by:</div><div class="line"> *     (1/18.432) * 2 * (2^WATCHDOG_TIMER_CLK_WIDTH)</div><div class="line"> *</div><div class="line"> * This will give you the duration since the last SPI transfer in</div><div class="line"> * microseconds (us).</div><div class="line"> *</div><div class="line"> * For example, if WATCHDOG_TIMER_CLK_WIDTH = 6, here&#39;s how you would</div><div class="line"> * convert into time assuming the fpga returned a reading of 1265 ticks:</div><div class="line"> *     time_in_us = [ 1265 * (1/18.432) * 2 * (2^6) ] = 8784.7us</div><div class="line"> *</div><div class="line"> * The precision would be in increments of the multiplier. For</div><div class="line"> * this example, that is:</div><div class="line"> *     time_precision = 6.94us</div><div class="line"> *</div><div class="line"> */</div><div class="line">float dt = static_cast&lt;float&gt;(encDeltas[4]) * (1 / 18.432e6) * 2 * 128;</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Feb 3 2020 13:37:32 for GT RoboCup SSL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
